/* eslint-disable no-console */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment

import CustomVideoElement from "custom-video-element";
import shaka from "shaka-player";

function onErrorEvent(event: Event & { detail?: shaka.util.Error }) {
    // Extract the shaka.util.Error object from the event.
    if (event.detail) onError(event.detail);
}

function onError(error: shaka.util.Error) {
    // Log the error.
    console.error("Error code", error.code, "object", error);
}

class ShakaVideoElement extends CustomVideoElement {
    player: shaka.Player | null;

    constructor() {
        super();
        this.player = null;

        if (shaka.Player.isBrowserSupported()) {
            this.player = new shaka.Player();
            this.player.attach(this.nativeEl);

            // Listen for error events.
            this.player.addEventListener("error", onErrorEvent);
        } else {
            // This browser does not have the minimum set of APIs we need.
            console.error("Browser does not support Shaka Player");
        }
    }

    get src() {
        // Use the attribute value as the source of truth.
        // No need to store it in two places.
        // This avoids needing a to read the attribute initially and update the src.
        return this.getAttribute("src") as string;
    }

    set src(val: string) {
        // If being set by attributeChangedCallback,
        // dont' cause an infinite loop
        if (val !== this.src) {
            this.setAttribute("src", val);
        }
    }

    set subtitles(value) {
        if (value !== this.subtitles) {
            this.setAttribute("subtitles", value as string);
        }
    }

    get subtitles() {
        return this.getAttribute("subtitles");
    }

    async load() {
        if (!this.player) {
            return;
        }

        if (!this.src) {
            this.player.unload();
        } else {
            // Try to load a manifest.
            // This is an asynchronous process.
            try {
                await this.player.load(this.src);

                const subtitles = this.subtitles
                    ? (JSON.parse(this.subtitles) as {
                          url: string;
                          mimeType: string;
                          name: string;
                          code: string;
                          autoGenerated: boolean;
                      }[])
                    : [];

                subtitles.forEach((s) => {
                    if (!this.player) return;
                    this.player.addTextTrackAsync(s.url, s.code, "subtitles", s.mimeType);
                });
            } catch (e) {
                // onError is executed if the asynchronous load fails.
                onError(e as shaka.util.Error);
            }
        }
    }

    connectedCallback() {
        if (this.player && this.src) {
            this.load();
        }

        // Not preloading might require faking the play() promise
        // so that you can call play(), call load() within that
        // But wait until MANIFEST_PARSED to actually call play()
        // on the nativeEl.
        // if (this.preload === 'auto') {
        //   this.load();
        // }
    }

    disconnectedCallback() {
        this.player && this.player.unload();
    }
}

declare global {
    interface Window {
        ShakaVideoElement: typeof ShakaVideoElement;
    }
}

if (typeof window !== "undefined" && !window.customElements.get("shaka-video")) {
    window.customElements.define("shaka-video", ShakaVideoElement);
    window.ShakaVideoElement = ShakaVideoElement;
}

export default ShakaVideoElement;
